#include <iostream>
#include <vector>
#include <fstream>
#include <chrono>
#include <limits>
#include <mutex>
#include <atomic>
#include <thread>
#include <algorithm>

using namespace std;

const double INF = numeric_limits<double>::infinity();
mutex mtx;
atomic<bool> timeout_occurred(false);

// Structure to store a solution of cost and path
struct Solution {
    double cost = INF;
    vector<int> path;

    Solution() : cost(INF) {} // Default constructor
    Solution(double c, vector<int> p) : cost(c), path(move(p)) {} // Constructor with parameters
};

// Function to calculate the MST heuristic for the unvisited nodes
double calculateMSTHeuristic(const vector<vector<double>>& adj, const vector<bool>& visited) {
    int N = adj.size();
    vector<double> key(N, INF); // Store minimum weight edge
    vector<bool> inMST(N, false);
    double result = 0; // Store the final result

    // Prim's algorithm to calculate MST heuristic
    for (int count = 0; count < N; count++) {
        // Pick the minimum key vertex not yet included in MST
        double min = INF;
        int u = -1;
        for (int v = 0; v < N; v++) {
            if (!visited[v] && !inMST[v] && key[v] < min) {
                min = key[v], u = v;
            }
        }

        if (u == -1) {
            break; // Disconnected graph or all vertices included
        }

        // Add the picked vertex to the MST Set
        inMST[u] = true;

        // Update key value and parent index of the adjacent vertices of the picked vertex
        for (int v = 0; v < N; v++) {
            if (adj[u][v] && !visited[v] && !inMST[v] && adj[u][v] < key[v]) {
                key[v] = adj[u][v];
            }
        }
    }

    // Accumulate weights of edges in the MST
    for (int i = 0; i < N; i++) {
        if (!visited[i] && inMST[i]) {
            result += key[i];
        }
    }
    return result;
}

// Recursive function to explore all possible TSP paths
void TSPRec(const vector<vector<double>>& adj, vector<int>& currentPath, vector<bool>& visited, int currentLevel, double& minCost, vector<int>& bestPath, double currentCost, chrono::steady_clock::time_point endTime) {
    if(chrono::steady_clock::now() > endTime || timeout_occurred.load()) {
        timeout_occurred.store(true);
        return;
    }
    
    int N = adj.size();
    // Base case: if all cities are visited
    if (currentLevel == N) {
        // Check if there is a returning edge
        if (adj[currentPath[N - 1]][currentPath[0]] > 0) {
            double totalCost = currentCost + adj[currentPath[N - 1]][currentPath[0]];
            if (totalCost < minCost) {
                minCost = totalCost;
                bestPath = currentPath;
                bestPath.push_back(currentPath[0]); // Complete the cycle
            }
        }
        return;
    }

    // Recursive case: go through all cities to build the path
    for (int i = 0; i < N; ++i) {
        if (!visited[i]) {
            visited[i] = true;
            currentPath[currentLevel] = i;
            double newCost = currentCost + (currentLevel == 0 ? 0 : adj[currentPath[currentLevel - 1]][i]);

            // Pruning: Check if the current partial solution can lead to a better solution
            if (newCost + calculateMSTHeuristic(adj, visited) < minCost) {
                TSPRec(adj, currentPath, visited, currentLevel + 1, minCost, bestPath, newCost, endTime);
            }

            visited[i] = false; // Backtrack
        }
    }
}

// Modified version of ParallelTSP function with detailed English comments
void ParallelTSP(vector<vector<double>>& adj, int startNode, double& globalMinCost, vector<int>& globalBestPath, int N, chrono::steady_clock::time_point endTime) {
    vector<thread> threads; // Vector to hold thread objects
    mutex localMutex; // Mutex to protect thread-local variables
    vector<Solution> solutions(N); // Vector to store solutions generated by each thread

    // Loop through all nodes to explore possible TSP paths
    for (int nextNode = 0; nextNode < N; ++nextNode) {
        if(timeout_occurred.load()) {
            break;
        }

        // Skip the startNode itself
        if (startNode == nextNode) continue;
        
        // Create a thread to explore TSP path starting from startNode to nextNode
        threads.push_back(thread([&, nextNode]() {
            // Initialize local variables for this thread
            vector<int> localPath(N + 1, -1); // Initialize localPath with -1
            vector<bool> localVisited(N, false); // Initialize localVisited with false
            double localMinCost = INF; // Initialize localMinCost with infinity
            vector<int> localBestPath; // Initialize localBestPath
            
            // Set startNode and nextNode as visited
            localPath[0] = startNode;
            localPath[1] = nextNode;
            localVisited[startNode] = true;
            localVisited[nextNode] = true;

            // Calculate the cost of the edge from startNode to nextNode
            double newCost = adj[startNode][nextNode];
            
            // Call the recursive function to explore TSP path
            TSPRec(adj, localPath, localVisited, 2, localMinCost, localBestPath, newCost, endTime);

            // Lock the local mutex and update the local solution if it's better than the previous one
            lock_guard<mutex> guard(localMutex);
            if (localMinCost < solutions[nextNode].cost) {
                solutions[nextNode].cost = localMinCost;
                solutions[nextNode].path = localBestPath;
            }
        }));
    }

    // Wait for all threads to finish
    for (auto& t : threads) {
        t.join();
    }

    // Update global solution based on the results from each thread
    for (const auto& sol : solutions) {
        if (sol.cost < globalMinCost) {
            // Lock the global mutex and update the global solution
            lock_guard<mutex> guard(mtx);
            globalMinCost = sol.cost;
            globalBestPath = sol.path;
        }
    }
}

int main() {
    // Input filename from user
    string fname;
    cout << "Enter the complete input filename: ";
    cin >> fname;

    // Open input file
    ifstream inputFile(fname);
    if (!inputFile.is_open()) {
        cerr << "Error opening: " << fname << endl;
        return 1;
    }

    // Read number of nodes (N) from input file
    int N;
    inputFile >> N;

    // Create adjacency matrix to store graph edges
    vector<vector<double>> adj(N, vector<double>(N));
    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; j++)
            inputFile >> adj[i][j];

    // Start measuring time
    auto start = chrono::high_resolution_clock::now();
    auto endTime = start + chrono::seconds(10);

    // Initialize global variables to store the best solution
    double globalMinCost = INF;
    vector<int> globalBestPath;

    // Open a thread for every starting node.
    vector<thread> threads;
    for (int startNode = 0; startNode < N; ++startNode) {
        threads.push_back(thread(ParallelTSP, ref(adj), startNode, ref(globalMinCost), ref(globalBestPath), N, endTime));
    }

    // Wait for all threads to finish
    for (auto& t : threads) {
        t.join();
    }

    // Stop measuring time
    auto end = chrono::high_resolution_clock::now();

    // Output the minimum cost and corresponding path
    if (timeout_occurred.load()) {
        cout << "Timeout occurred. Best solution found within the given time:";
        cout << "Minimum cost: " << globalMinCost << endl;
        cout << "Path: ";
        for (int i : globalBestPath) {
            cout << i + 1 << " ";
        }
        cout<<endl;
    } else {
        cout << "Minimum cost: " << globalMinCost << endl;
        cout << "Path: ";
        for (int i : globalBestPath) {
            cout << i + 1 << " ";
        }
        cout << endl;
    }

    // Output the running time
    auto duration = chrono::duration_cast<chrono::milliseconds>(end - start).count();
    cout << "Running Time: " << duration << " ms" << endl;
    return 0;
}